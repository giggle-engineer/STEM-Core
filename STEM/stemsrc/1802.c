/************************************************************************/
/************************************************************************/
/*																		*/
/*					RCA/Harris/Intersil CDP1802 Simulator				*/
/*																		*/
/************************************************************************/
/************************************************************************/

#include <stdio.h>
#include "1802.H"						/* Header file for simulator */

#define	MEMSIZE				(4096)		/* Memory Size (power of 2) */
#define MEMMASK				(MEMSIZE-1)	/* Memory Mask */

										/* I/O Port functions */
#define INPORT(Port)		_1802_InHandler(Port)
#define OUTPORT(Port,Data)	_1802_OutHandler(Port,Data);

#ifdef	MSDOS
typedef unsigned int  		_UWORD;		/* 16 bit unsigned type */
typedef unsigned char 		_UBYTE;		/* 8 bit unsigned type */
#endif

#ifdef WINDOWS
typedef unsigned int  		_UWORD;		/* 16 bit unsigned type */
typedef unsigned char 		_UBYTE;		/* 8 bit unsigned type */
#endif

static _UWORD	D,DF,IE,P,X,T,R[16];	/* CPU Registers */
static _UWORD	Q,EF[4],IDLEFLAG,Temp;	/* Other registers and work var */
static _UBYTE  	Memory[MEMSIZE];		/* CPU Memory */

#include "1802mac.h"					/* All the Macros */

/************************************************************************/
/*						Write to memory function					    */
/************************************************************************/

static void _1802_Write(_UWORD Addr,_UBYTE Data)
{
Addr = Addr & MEMMASK;					/* Correct Range */
if ((Addr & 0x0E00) == 0x0800)			/* 800-9FF */
	{
	Addr = Addr & 0x1FF;				/* Range in RAM */
	Memory[Addr+0x800] = Data;			/* Update the value */
	}
}


/************************************************************************/
/*							Reset the Processor.						*/
/************************************************************************/

void CPU1802_Reset(void)
{
EF[0]=EF[1]=EF[2]=EF[3]=Q=0;			/* Zero the external hardware */
D=DF=T=X=P=IDLEFLAG=0;					/* Clear all registers except IE */
IE=1;									/* IE Set on Reset CPU */
R[0]=0;
}

/************************************************************************/
/*	Execute for a given number of cycles. The cycles refer to 8 clock   */
/*	pulses (see FN1305.PDF for details)									*/
/************************************************************************/

void CPU1802_Exec(int Cycles)
{
while (Cycles > 0)						/* Until run out of cycles */
	{
	Cycles = Cycles-2;					/* Most instructions are 2 cycles */
	switch(FETCH)						/* Switch on fetched opcode */
		{
		#include "_case.h"				/* Generated by GEN1802.C */
		}
	}
}

/************************************************************************/
/*				 Dump the status to an output stream					*/
/************************************************************************/

void CPU1802_Dump(FILE *Stream)
{
int i;
fprintf(Stream,"R[P]:%04x Mem(R[P]):%02x %02x %02x %02x ",
				R[P],READ(R[P]),READ(R[P]+1),READ(R[P]+2),READ(R[P]+3));
fprintf(Stream,"R[X]:%04x Mem(R[X]):%02x\n",R[X],READ(R[X]));
fprintf(Stream,"    D:%02x DF:%01x X:%1x P:%1x T:%02x Q:%01x IE:%01x ",D,DF,X,P,T,Q,IE);
fprintf(Stream,"EF:%1x %1x %1x %1x",EF[0],EF[1],EF[2],EF[3]);
for (i = 0;i < 16;i++)
	{
	if (i % 8 == 0) fprintf(Stream,"\n    ");
	fprintf(Stream,"R%1x:%04x ",i,R[i]);
	}
fprintf(Stream,"\n");
}

/************************************************************************/
/*				Read the Status of the CPU (READ ONLY)					*/
/************************************************************************/

void CPU1802_Status(struct CPU1802 *p)
{
int i;
p->D=D;p->DF=DF;p->IE=IE;				/* Copy the CPU Registers */
p->X=X;p->P=P;p->T=T;p->Q=Q;
for (i = 0;i < 16;i++) p->R[i] = R[i];	/* Copy register bank */
for (i = 0;i < 4;i++) p->EF[i] = EF[i];	/* Copy input flag status */
p->MemorySize = MEMSIZE;				/* Set up for memory access */
p->Memory = (unsigned char *)Memory;
}

/************************************************************************/
/*				Set the EFx values. Note we number them 0..3			*/
/************************************************************************/

void CPU1802_SetFlag(int FlagID,int Value)
{
if (FlagID >= 0 && FlagID < 4)          /* Update if valid */
		EF[FlagID] = (Value != 0) ? 1 : 0;
}

/************************************************************************/
/*							   Interrupt								*/
/************************************************************************/

void CPU1802_Interrupt(void)
{
if (IE != 0)							/* Only if interrupts enabled */
	{
	T = (X << 4) | P;					/* Save X and P */
	IE = 0;P = 1;X = 2;					/* Interrupt jump */
	}
}